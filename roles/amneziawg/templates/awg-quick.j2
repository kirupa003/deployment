#!/bin/bash
# AmneziaWG Quick Configuration Script
# Generated by Ansible

set -e

AWG="{{ _awg_binary }}"
CONFIG_SEARCH_PATHS=("{{ amneziawg_config_dir }}" "/etc/amneziawg")

die() {
    echo "[-] Error: $1" >&2
    exit 1
}

parse_options() {
    local interface_section=0 peer_section=0
    local line key value stripped v
    CONFIG_FILE="$1"
    [[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,15}$ ]] && CONFIG_FILE="${CONFIG_SEARCH_PATHS[0]}/$CONFIG_FILE.conf"
    [[ -e $CONFIG_FILE ]] || die "\`$CONFIG_FILE' does not exist"
    [[ $CONFIG_FILE =~ (^|/)([a-zA-Z0-9_=+.-]{1,15})\.conf$ ]] || die "The config file must be a valid interface name, followed by .conf"
    CONFIG_FILE="$(readlink -f "$CONFIG_FILE")"
    INTERFACE="${BASH_REMATCH[2]}"
    shopt -s nocasematch
    while read -r line || [[ -n $line ]]; do
        stripped="${line%%\#*}"
        key="${stripped%%=*}"; key="${key##*([[:space:]])}"; key="${key%%*([[:space:]])}"
        value="${stripped#*=}"; value="${value##*([[:space:]])}"; value="${value%%*([[:space:]])}"
        [[ $key == "["* ]] && { peer_section=0; interface_section=0; }
        [[ $key == "[Interface]" ]] && interface_section=1
        [[ $key == "[Peer]" ]] && peer_section=1
        if [[ $interface_section -eq 1 ]]; then
            case "$key" in
            Address) ADDRESSES+=( ${value//,/ } ) ;;
            DNS) DNS+=( ${value//,/ } ) ;;
            MTU) MTU="$value" ;;
            esac
        fi
    done < "$CONFIG_FILE"
    shopt -u nocasematch
}

cmd_usage() {
    cat >&2 <<-_EOF
Usage: $PROGRAM [ up | down | save | strip ] [ CONFIG_FILE | INTERFACE ]

  CONFIG_FILE is a configuration file, whose filename is the interface name
  followed by \`.conf'. Otherwise, INTERFACE is an interface name, with
  configuration found at /etc/amneziawg/INTERFACE.conf. It is to be readable
  by awg(8)'s \`setconf' sub-command, and must specify exactly one interface.
  For \`up', if INTERFACE already exists as a network interface, awg-quick(8)
  will use the existing interface and not create a new one.

_EOF
}

cmd_up() {
    local i
    [[ -z $(ip link show dev "$INTERFACE" 2>/dev/null) ]] || die "\`$INTERFACE' already exists"
    trap 'del_if; exit' INT TERM EXIT
    add_if
    set_config
    for i in "${ADDRESSES[@]}"; do
        add_addr "$i"
    done
    set_mtu_up
    set_dns
    for i in $(while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <($AWG show "$INTERFACE" allowed-ips) | sort -nr -k 2 -t /); do
        add_route "$i"
    done
    execute_hooks "${POST_UP[@]}"
    trap - INT TERM EXIT
}

cmd_down() {
    [[ " $(awg show interfaces) " == *" $INTERFACE "* ]] || die "\`$INTERFACE' is not a AmneziaWG interface"
    execute_hooks "${PRE_DOWN[@]}"
    [[ $SAVE_CONFIG -eq 0 ]] || save_config
    del_if
}

add_if() {
    cmd ip link add "$INTERFACE" type wireguard
}

del_if() {
    cmd ip link delete dev "$INTERFACE"
}

add_addr() {
    cmd ip -4 address add "$1" dev "$INTERFACE"
}

set_mtu_up() {
    local mtu=0 endpoint output
    if [[ -n $MTU ]]; then
        cmd ip link set mtu "$MTU" up dev "$INTERFACE"
        return
    fi
    while read -r _ endpoint; do
        [[ $endpoint =~ ^\[?([a-z0-9:.]+)\]?:[0-9]+$ ]] || continue
        output="$(ip route get "${BASH_REMATCH[1]}" 2>/dev/null)" || continue
        [[ ( $output =~ mtu\ ([0-9]+) || ( $output =~ dev\ ([^ ]+) && $(ip link show dev "${BASH_REMATCH[1]}" 2>/dev/null) =~ mtu\ ([0-9]+) ) ) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
    done < <($AWG show "$INTERFACE" endpoints)
    if [[ $mtu -eq 0 ]]; then
        read -r output < <(ip route show default 2>/dev/null) || true
        [[ ( $output =~ mtu\ ([0-9]+) || ( $output =~ dev\ ([^ ]+) && $(ip link show dev "${BASH_REMATCH[1]}" 2>/dev/null) =~ mtu\ ([0-9]+) ) ) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
    fi
    [[ $mtu -gt 0 ]] || mtu=1500
    cmd ip link set mtu $(( mtu - 80 )) up dev "$INTERFACE"
}

set_dns() {
    [[ ${#DNS[@]} -gt 0 ]] || return 0
    printf 'nameserver %s\n' "${DNS[@]}" | cmd resolvconf -a "tun.$INTERFACE" -m 0 -x
}

set_config() {
    cmd "$AWG" setconf "$INTERFACE" "$CONFIG_FILE"
}

save_config() {
    local old_umask new_config current_config address cmd
    new_config=$($AWG showconf "$INTERFACE")
    old_umask="$(umask)"
    umask 077
    current_config="$(cat "$CONFIG_FILE")"
    case "$new_config" in *"$current_config"*) exit 0 ;; esac
    echo "$new_config" > "$CONFIG_FILE.tmp" || die "Could not write configuration file"
    sync "$CONFIG_FILE.tmp"
    mv "$CONFIG_FILE.tmp" "$CONFIG_FILE" || die "Could not move configuration file"
    umask "$old_umask"
}

add_route() {
    [[ $1 == */32 ]] && echo "[#] ip -4 route add $1 dev $INTERFACE table main" && ip -4 route add "$1" dev "$INTERFACE" table main
    [[ $1 == */128 ]] && echo "[#] ip -6 route add $1 dev $INTERFACE table main" && ip -6 route add "$1" dev "$INTERFACE" table main
    return 0
}

execute_hooks() {
    local hook
    for hook in "$@"; do
        echo "[#] $hook" >&2
        (eval "$hook")
    done
}

cmd() {
    echo "[#] $*" >&2
    "$@"
}

# Main execution
PROGRAM="${0##*/}"
ARGS=( "$@" )
CMD=""
CONFIG_FILE=""
INTERFACE=""
ADDRESSES=( )
MTU=""
DNS=( )
POST_UP=( )
PRE_DOWN=( )
SAVE_CONFIG=0

case "${1:-help}" in
up) CMD=cmd_up ;;
down) CMD=cmd_down ;;
save) CMD=cmd_save; SAVE_CONFIG=1 ;;
strip) CMD=cmd_strip ;;
*) cmd_usage; exit 1 ;;
esac

parse_options "$2"
$CMD