#!/bin/bash
# VPN Infrastructure Alert Testing Script
# Generated by Ansible - Do not edit manually

set -euo pipefail

# Configuration
GRAFANA_URL="{{ monitoring_grafana_url }}"
GRAFANA_API_KEY="{{ monitoring_grafana_api_key }}"
ALERTMANAGER_URL="{{ monitoring_alertmanager_url }}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to log messages
log_message() {
    echo -e "${GREEN}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[$(date '+%Y-%m-%d %H:%M:%S')] WARNING:${NC} $1"
}

log_error() {
    echo -e "${RED}[$(date '+%Y-%m-%d %H:%M:%S')] ERROR:${NC} $1"
}

# Function to test Grafana connectivity
test_grafana_connectivity() {
    log_message "Testing Grafana connectivity..."
    
    if curl -s -f "$GRAFANA_URL/api/health" > /dev/null; then
        log_message "âœ“ Grafana is accessible"
        return 0
    else
        log_error "âœ— Grafana is not accessible at $GRAFANA_URL"
        return 1
    fi
}

# Function to test alert rules
test_alert_rules() {
    log_message "Testing alert rules configuration..."
    
    if [[ -z "$GRAFANA_API_KEY" ]]; then
        log_warning "No Grafana API key provided, skipping alert rules test"
        return 0
    fi
    
    local response
    response=$(curl -s -H "Authorization: Bearer $GRAFANA_API_KEY" \
                   "$GRAFANA_URL/api/ruler/grafana/api/v1/rules" 2>/dev/null || echo "error")
    
    if [[ "$response" == "error" ]]; then
        log_error "âœ— Failed to retrieve alert rules"
        return 1
    fi
    
    local rule_count
    rule_count=$(echo "$response" | jq -r 'length' 2>/dev/null || echo "0")
    
    if [[ "$rule_count" -gt 0 ]]; then
        log_message "âœ“ Found $rule_count alert rule groups"
        return 0
    else
        log_warning "No alert rules found"
        return 1
    fi
}

# Function to test notification channels
test_notification_channels() {
    log_message "Testing notification channels..."
    
    if [[ -z "$GRAFANA_API_KEY" ]]; then
        log_warning "No Grafana API key provided, skipping notification channels test"
        return 0
    fi
    
    local response
    response=$(curl -s -H "Authorization: Bearer $GRAFANA_API_KEY" \
                   "$GRAFANA_URL/api/alert-notifications" 2>/dev/null || echo "error")
    
    if [[ "$response" == "error" ]]; then
        log_error "âœ— Failed to retrieve notification channels"
        return 1
    fi
    
    local channel_count
    channel_count=$(echo "$response" | jq -r 'length' 2>/dev/null || echo "0")
    
    if [[ "$channel_count" -gt 0 ]]; then
        log_message "âœ“ Found $channel_count notification channels"
        return 0
    else
        log_warning "No notification channels found"
        return 1
    fi
}

# Function to send test alert
send_test_alert() {
    log_message "Sending test alert..."
    
    local test_alert='{
        "alerts": [
            {
                "labels": {
                    "alertname": "TestAlert",
                    "instance": "test-server",
                    "severity": "warning",
                    "service": "vpn-infrastructure"
                },
                "annotations": {
                    "summary": "Test alert from VPN infrastructure monitoring",
                    "description": "This is a test alert to verify the alerting pipeline is working correctly."
                },
                "startsAt": "'$(date -Iseconds)'",
                "endsAt": "'$(date -d '+5 minutes' -Iseconds)'"
            }
        ]
    }'
    
    if curl -s -f -X POST \
            -H "Content-Type: application/json" \
            -d "$test_alert" \
            "$ALERTMANAGER_URL/api/v1/alerts" > /dev/null; then
        log_message "âœ“ Test alert sent successfully"
        return 0
    else
        log_error "âœ— Failed to send test alert"
        return 1
    fi
}

# Function to check alert status
check_alert_status() {
    log_message "Checking active alerts..."
    
    local response
    response=$(curl -s "$ALERTMANAGER_URL/api/v1/alerts" 2>/dev/null || echo "error")
    
    if [[ "$response" == "error" ]]; then
        log_error "âœ— Failed to retrieve alerts from Alertmanager"
        return 1
    fi
    
    local alert_count
    alert_count=$(echo "$response" | jq -r '.data | length' 2>/dev/null || echo "0")
    
    log_message "Found $alert_count active alerts"
    
    if [[ "$alert_count" -gt 0 ]]; then
        echo "$response" | jq -r '.data[] | "- \(.labels.alertname): \(.annotations.summary)"' 2>/dev/null || true
    fi
    
    return 0
}

# Function to validate dashboard accessibility
test_dashboards() {
    log_message "Testing dashboard accessibility..."
    
    local dashboards=(
        "vpn-infrastructure-overview"
        "server-health-performance"
        "vpn-service-metrics"
    )
    
    local success_count=0
    
    for dashboard in "${dashboards[@]}"; do
        if [[ -f "{{ monitoring_dashboards_dir }}/$dashboard.json" ]]; then
            log_message "âœ“ Dashboard found: $dashboard"
            success_count=$((success_count + 1))
        else
            log_warning "âœ— Dashboard not found: $dashboard"
        fi
    done
    
    log_message "Dashboard test completed: $success_count/${#dashboards[@]} dashboards found"
    
    if [[ $success_count -eq ${#dashboards[@]} ]]; then
        return 0
    else
        return 1
    fi
}

# Function to run comprehensive test
run_comprehensive_test() {
    log_message "Starting comprehensive VPN infrastructure alert testing..."
    
    local test_results=()
    
    # Run all tests
    test_grafana_connectivity && test_results+=("grafana:pass") || test_results+=("grafana:fail")
    test_alert_rules && test_results+=("rules:pass") || test_results+=("rules:fail")
    test_notification_channels && test_results+=("notifications:pass") || test_results+=("notifications:fail")
    test_dashboards && test_results+=("dashboards:pass") || test_results+=("dashboards:fail")
    
    # Optional tests (don't fail if these don't work)
    send_test_alert && test_results+=("test_alert:pass") || test_results+=("test_alert:skip")
    check_alert_status && test_results+=("alert_status:pass") || test_results+=("alert_status:skip")
    
    # Summary
    log_message "Test Summary:"
    local pass_count=0
    local total_count=0
    
    for result in "${test_results[@]}"; do
        local test_name="${result%:*}"
        local test_status="${result#*:}"
        total_count=$((total_count + 1))
        
        case "$test_status" in
            "pass")
                echo -e "  âœ“ ${GREEN}$test_name${NC}"
                pass_count=$((pass_count + 1))
                ;;
            "fail")
                echo -e "  âœ— ${RED}$test_name${NC}"
                ;;
            "skip")
                echo -e "  - ${YELLOW}$test_name (skipped)${NC}"
                pass_count=$((pass_count + 1))  # Don't count skipped as failures
                ;;
        esac
    done
    
    log_message "Overall result: $pass_count/$total_count tests passed"
    
    if [[ $pass_count -eq $total_count ]]; then
        log_message "ðŸŽ‰ All tests passed! VPN infrastructure monitoring is working correctly."
        return 0
    else
        log_error "âŒ Some tests failed. Please check the configuration."
        return 1
    fi
}

# Main execution
main() {
    case "${1:-comprehensive}" in
        "grafana")
            test_grafana_connectivity
            ;;
        "rules")
            test_alert_rules
            ;;
        "notifications")
            test_notification_channels
            ;;
        "dashboards")
            test_dashboards
            ;;
        "test-alert")
            send_test_alert
            ;;
        "status")
            check_alert_status
            ;;
        "comprehensive"|*)
            run_comprehensive_test
            ;;
    esac
}

# Check dependencies
if ! command -v curl >/dev/null 2>&1; then
    log_error "curl is required but not installed"
    exit 1
fi

if ! command -v jq >/dev/null 2>&1; then
    log_warning "jq is not installed, some tests may not work properly"
fi

# Run main function
main "$@"